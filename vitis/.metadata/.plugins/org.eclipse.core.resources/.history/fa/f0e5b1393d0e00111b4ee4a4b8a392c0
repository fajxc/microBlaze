#include "xil_io.h"
#include "xil_printf.h"
#include "sleep.h"
#include "xuartlite_l.h"
#include "xparameters.h"
#include "xil_types.h"
#include <stdint.h>
#include <string.h>

#include "weights_w1.h"
#include "weights_b1.h"
#include "weights_w2.h"
#include "weights_b2.h"

#define BASE 0x44A00000
#define REG0 (BASE + 0x00)
#define REG1 (BASE + 0x04)
#define REG2 (BASE + 0x08)
#define REG3 (BASE + 0x0C)
#define REG4 (BASE + 0x10) // now: dbg_score0 this is the hh tag
#define REG5 (BASE + 0x14) // now: dbg_acc0 (you repurposed to oo_use_tag)
#define REG6 (BASE + 0x18)  // now: HW w2_used for (o=0,h=0)
#define REG7 (BASE + 0x1C)  // now: HW hs_used for (o=0,h=0)

#ifndef UART_BASE
#define UART_BASE XPAR_UARTLITE_0_BASEADDR
#endif

#define INPUT_SIZE  784
#define HIDDEN_SIZE 32
#define OUTPUT_SIZE 10

uint8_t  input_image[INPUT_SIZE];
int32_t  hidden_layer[HIDDEN_SIZE];
int32_t  output_layer[OUTPUT_SIZE];

static inline u8 uart_getc_blocking(void) {
    while (XUartLite_IsReceiveEmpty(UART_BASE)) {}
    return Xil_In8(UART_BASE + XUL_RX_FIFO_OFFSET);
}

static inline void nn_write_pixel(u32 idx, u8 px) {
    Xil_Out32(REG2, idx);
    Xil_Out32(REG1, (u32)px);
}

static inline void nn_start_pulse(void) {
    Xil_Out32(REG0, 1u);
    usleep(10);
    Xil_Out32(REG0, 0u);
}

static inline u32 nn_wait_done(void) {
    while (Xil_In32(REG3) & 0x1u) {}
    while ((Xil_In32(REG3) & 0x1u) == 0u) {}
    return Xil_In32(REG3);
}

// Software MLP
static inline int32_t relu(int32_t x) { return (x > 0) ? x : 0; }

void layer1_forward(const uint8_t* input, int32_t* output) {
    for (int h = 0; h < HIDDEN_SIZE; h++) {
        int32_t accum = 0;
        for (int i = 0; i < INPUT_SIZE; i++)
            accum += (int32_t)w1[h][i] * (int32_t)input[i];
        accum += b1[h];
        output[h] = relu(accum);
    }
}

void layer2_forward(const int32_t* hidden, int32_t* output) {
    for (int o = 0; o < OUTPUT_SIZE; o++) {
        int32_t accum = 0;
        for (int h = 0; h < HIDDEN_SIZE; h++) {
            int32_t hidden_scaled = hidden[h] / 256;
            accum += (int32_t)w2[o][h] * hidden_scaled;
        }
        accum += b2[o];
        output[o] = accum;
    }
}

int argmax(const int32_t* array, int length) {
    int max_idx = 0;
    int32_t max_val = array[0];
    for (int i = 1; i < length; i++)
        if (array[i] > max_val) { max_val = array[i]; max_idx = i; }
    return max_idx;
}

int mlp_inference(const uint8_t* img) {
    layer1_forward(img, hidden_layer);
    layer2_forward(hidden_layer, output_layer);
    return argmax(output_layer, OUTPUT_SIZE);
}

// REG7 = HW hs_used (scaled hidden used in multiply for o=0,h=0)
// REG6 = HW w2_used (weight used in multiply for o=0,h=0), sign-extended to int32 in RTL
static inline int32_t arshift8(int32_t x) { return x >> 8; } // arithmetic shift on signed int32

static void print_l2_debug_min(u32 hw_pred)
{
    // HW reads (after DONE)
    int32_t hw_hs_used = (int32_t)Xil_In32(REG7);
    int32_t hw_w2_used = (int32_t)Xil_In32(REG6);

    // Optional tags (only if you really wired them there)
    int32_t hw_oo_tag  = (int32_t)Xil_In32(REG5);
    int32_t hw_hh_tag  = (int32_t)Xil_In32(REG4);

    // SW equivalents for (o=0,h=0)
    int32_t sw_raw_h0  = hidden_layer[0];
    int32_t sw_hs0     = arshift8(sw_raw_h0);              // exact match to >>> 8
    int32_t sw_w2_00   = (int32_t)w2[0][0];

    // Terms
    int32_t hw_term0   = hw_w2_used * hw_hs_used;
    int32_t sw_term0   = sw_w2_00 * sw_hs0;

    xil_printf("DBG2: HW hs_used=%d | SW hs0=%d\r\n", hw_hs_used, sw_hs0);
    xil_printf("DBG2: HW w2_used=%d | SW w2_00=%d\r\n", hw_w2_used, sw_w2_00);
    xil_printf("DBG2: HW term0=%d | SW term0=%d\r\n", hw_term0, sw_term0);

    // Only meaningful if tags are actually exposed/mapped
    xil_printf("DBG2: HW tag oo=%d hh=%d\r\n", hw_oo_tag, hw_hh_tag);

    // keep your existing useful stuff
    xil_printf("SW logit[HWpred]=%d\r\n", output_layer[hw_pred]);
}


static void run_fixed_input_test(void) {
    xil_printf("=== FIXED INPUT TEST ===\r\n");

    for (int run = 0; run < 3; run++) {
        for (u32 idx = 0; idx < 784u; idx++)
            nn_write_pixel(idx, 0u);
        nn_write_pixel(0u, 255u);

        nn_start_pulse();
        u32 status  = nn_wait_done();
        u32 hw_pred = (status >> 4) & 0xFu;

        memset(input_image, 0, INPUT_SIZE);
        input_image[0] = 255;
        int sw_pred = mlp_inference(input_image);

        // HW debug AFTER done
        //int32_t hw_logit0 = (int32_t)Xil_In32(REG4);
        //int32_t hw_acc0   = (int32_t)Xil_In32(REG5);

        int32_t sw_logit0 = output_layer[0];
        int32_t sw_acc0   = sw_logit0 - (int32_t)b2[0];

        //xil_printf("DBG: HW acc0=%d HW logit0=%d | SW acc0=%d SW logit0=%d\r\n",
                //   hw_acc0, hw_logit0, sw_acc0, sw_logit0);

        print_l2_debug_min(hw_pred);

        xil_printf("Run %d: HW:%u SW:%u %s\r\n",
                   run,
                   (unsigned)hw_pred,
                   (unsigned)sw_pred,
                   (hw_pred == (u32)sw_pred) ? "MATCH" : "MISMATCH");
    }

    xil_printf("SW hidden[0..7] for fixed input: ");
    for (int i = 0; i < 8; i++)
        xil_printf("%d ", hidden_layer[i]);
    xil_printf("\r\n");

    xil_printf("=== END FIXED INPUT TEST ===\r\n");
}

int main(void) {
    xil_printf("\r\n=== HW vs SW COMPARISON TEST ===\r\n");
    Xil_Out32(REG0, 0u);
    usleep(1000);

    run_fixed_input_test();

    while (1) {
        xil_printf("\r\nCMD? (1=send image, 4=menu)\r\n");
        u8 cmd = uart_getc_blocking();

        if (cmd == '4') {
            xil_printf("1: Send image\r\n4: Menu\r\n");
            continue;
        }
        if (cmd != '1') {
            xil_printf("Unknown cmd '%c'\r\n", cmd);
            continue;
        }

        while (!XUartLite_IsReceiveEmpty(UART_BASE))
            (void)Xil_In8(UART_BASE + XUL_RX_FIFO_OFFSET);

        xil_printf("READY\r\n");

        for (u32 idx = 0; idx < 784u; idx++) {
            u8 px = uart_getc_blocking();
            input_image[idx] = px;
            nn_write_pixel(idx, px);
        }

        nn_start_pulse();
        u32 status  = nn_wait_done();
        xil_printf("STATUS=0x%08x\r\n", (unsigned)status);
        u32 hw_pred = (status >> 4) & 0xFu;

        int sw_pred = mlp_inference(input_image);

        // HW debug AFTER done
        //int32_t hw_logit0 = (int32_t)Xil_In32(REG4);
        //int32_t hw_acc0   = (int32_t)Xil_In32(REG5);

        int32_t sw_logit0 = output_layer[0];
        int32_t sw_acc0   = sw_logit0 - (int32_t)b2[0];

        //xil_printf("DBG: HW acc0=%d HW logit0=%d | SW acc0=%d SW logit0=%d\r\n",
                   //hw_acc0, hw_logit0, sw_acc0, sw_logit0);

        // Minimal layer2 debug that isolates pairing
        print_l2_debug_min(hw_pred);

        xil_printf("SW logits: ");
        for (int o = 0; o < 10; o++) xil_printf("%d ", output_layer[o]);
        xil_printf("\r\nSW pred=%d\r\n", sw_pred);

        xil_printf("HW:%u SW:%u\r\n", (unsigned)hw_pred, (unsigned)sw_pred);

        xil_printf("SW hidden[0..7]: ");
        for (int i = 0; i < 8; i++) xil_printf("%d ", hidden_layer[i]);
        xil_printf("\r\n");

        xil_printf("PRED:%u\r\n", (unsigned)sw_pred);
    }
}
